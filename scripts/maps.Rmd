---
title: "maps"
author: "steppe"
date: "3/22/2022"
output: pdf_document
---

```{r Load Libraries, warning = F, message = F}
shhh <- suppressPackageStartupMessages
#set_here(path = "/hdd/revisionary_taxonomy")
shhh(library(here))
shhh(library(tidyverse))
shhh(library(sf))
shhh(library(tigris))
shhh(library(ggspatial))
source('functions.R')
rm(shhh)
```

```{r import plant data, echo = F}
astragalus <- st_read(paste0(here(), '/data/processed/', 'astragalus.shp'), quiet = T)
eriogonum <- st_read(paste0(here(), '/data/processed/', 'eriogonum.shp'), quiet = T)
townsendia <- st_read(paste0(here(), '/data/processed/', 'townsendia.shp'), quiet = T)
```

```{r Create Boundary boxes, echo = F}
pts <- bind_rows(astragalus, eriogonum, townsendia) %>% 
  st_transform(4269) 

bb <- pts %>% 
  st_transform(32613) %>% 
  st_buffer(50000) %>% 
  st_transform(4269) %>% 
  st_convex_hull() %>% 
  st_bbox()
bb1 <- pts %>% 
  st_transform(32613) %>% 
  st_buffer(7500) %>% 
  st_transform(4269) %>% 
  st_convex_hull() %>% 
  st_bbox()

rm(astragalus, eriogonum, townsendia)
```


```{r download political boundaries, eval = F}
counties_filt <- tigris::counties(state = c('AZ', 'CO', 'UT', 'NM'))
counties_filt <- st_crop(counties_filt, bb)

st_write(counties_filt, paste0(here(), '/data/processed/counties.shp'))
```

```{r Evaluate downloaded Political Data}
counties_filt <- st_read(paste0(here(), '/data/processed/counties.shp'), 
                         quiet = T)
counties_filt1 <- st_cast(counties_filt, 'MULTILINESTRING')

ggplot(counties_filt1) +
  geom_sf() +
  geom_sf(data = pts, aes(color = scntfcN)) +
  coord_sf(xlim = c(bb1[1], bb1[3]), ylim = c(bb1[2], bb1[4])) +  
  theme_bw() 
  
rm(bb)
```

We will download  basemap for making a large overview map
```{r download a basemap, eval = F}
bb2 <- bb1
names(bb2) <- c('left', 'bottom', 'right', 'top')
basemap <- ggmap::get_stamenmap(bb2,  maptype = "terrain")

coarse_basemap <- tempfile(tmpdir = paste0(here(), '/data/processed/'))
saveRDS(basemap, file = coarse_basemap)
rm(bb2, coarse_basemap)
```

```{r Import basemap from Local}
basemap <- readRDS(paste0(here(), "/data/processed//file82021d31710"))

ggmap::ggmap(basemap) +
  geom_sf(data = counties_filt1, inherit.aes = FALSE,) +
  geom_sf(data = pts, aes(color = scntfcN), inherit.aes = FALSE,) +
  coord_sf(xlim = c(bb1[1], bb1[3]), ylim = c(bb1[2], bb1[4])) +  
  theme_bw() 
```

## Download and process Road Data
```{r Download roads data for relevant counties and subset, eval = F}

counties <- st_intersects(counties_filt, pts)
counties <- counties %>% # find counties which intersect
  map(~ if_else(length(.) > 0, T, F))  %>% 
  unlist()
counties <- counties_filt[counties == TRUE, ]

counties <- bind_rows(counties,
                  counties_filt[counties_filt$NAME %in% c('Montrose','Ouray'),])

lst_result <- apply(counties, 1, john_tigger)
cnty_rds <- bind_rows(lst_result) %>% st_as_sf()
cnty_rds <- st_crop(cnty_rds, bb1) # reduce extent.

st_write(cnty_rds, paste0(here(), '/data/processed/roads.shp'), quiet =T)
rm(counties, lst_result, john_tigger)
```

```{r read in county road data}
cnty_rds <- st_read(paste0(here(), '/data/processed/roads.shp'), quiet =T)
table(cnty_rds$RTTYP)
```

The [US Census Bureau Route Type Codes](https://www.census.gov/library/reference/code-lists/route-type-codes.html), are displayed below for a lookup table.

   Route Type Code  	      Route Type Code Description
--------------------     ---------------------------------
        C 	                      County
        I 	                      Interstate
        M 	                      Common Name
        O 	                      Other
        S 	                      State recognized
        U  	                      U.S.
------------------      ---------------------------------

We will subset this data frame to have a course map for our over map reference maps

```{r Subset to Coarse Roads}
spp_cols <- c(
  'darkorange4', 'darkseagreen4', 
  'slateblue4', 'deeppink4', 
  'tan2', 'thistle4')

rds_coarse <- filter(cnty_rds, RTTYP %in% c('I','U','S'))

topo_base <- ggmap::ggmap(basemap) +
  geom_sf(data = counties_filt1, lty = 3, inherit.aes = FALSE) +
  geom_sf(data = pts, aes(color = scntfcN), inherit.aes = FALSE) +
  geom_sf(data = rds_coarse, inherit.aes = F, colour = 'grey20') +
  scale_color_manual(values= spp_cols)+
  coord_sf(xlim = c(bb1[1], bb1[3]), ylim = c(bb1[2], bb1[4])) +  
  labs(title="Sampled Populations",  x ="", y = "", color = 'Species') +
  theme_bw() +
  theme(axis.text.x=element_blank(),
        axis.text.y = element_blank(),
        plot.title = element_text(hjust = 0.5),
        legend.position="bottom",
        legend.direction = "horizontal"
        ) +
    theme(panel.border = element_rect(colour = "black", fill=NA),
        legend.background = element_rect(linetype = 2, size = 0.5, colour = 1))
  
```


```{r subset finer roads to relevant areas, eval = F}
cnty_rds_local <- cnty_rds %>% filter(! RTTYP %in% c('I','U','S'))
site_adj_roads <- pts %>% 
  st_transform(32613) %>% 
  st_buffer(15000) %>% 
  st_union() %>% 
  st_as_sf() %>% 
  st_transform(4269) %>% 
  st_intersection(., cnty_rds_local)

site_adj_roads <- rmapshaper::ms_simplify(site_adj_roads, keep = 0.5)
site_adj_roads <- st_as_sf(site_adj_roads)

ggmap::ggmap(basemap) +
  geom_sf(data = counties_filt1, lty = 3, inherit.aes = FALSE) +
  geom_sf(data = rds_coarse, inherit.aes = F, colour = 'grey20') +
  geom_sf(data = site_adj_roads, inherit.aes = F) +
  geom_sf(data = pts, aes(color = scntfcN), inherit.aes = FALSE) +
  coord_sf(xlim = c(bb1[1], bb1[3]), ylim = c(bb1[2], bb1[4])) +  
  theme_bw() 

st_write(site_adj_roads, paste0(here(), '/data/processed/roads_nr_sites.shp'), quiet =T)
rm(cnty_rds_local, cnty_rds)
```

```{r read roads back in, eval = F}
site_adj_roads <- st_read(paste0(here(), '/data/processed/roads_nr_sites.shp'), quiet =T)
```


## Determine which plots are in proximity to each other

Each population will have a one page print out, with three plots: 
  - the overview plot of all populations, 
  - a plot within a 16 km boundary box, 
  -  a map of 2.5 km around the population. 
We will work on creating as few of the second plot as possible. We will use a window of 12km, rather than 16km to ensure some points are not squished to the side of maps.


```{r}

rm(cnty_rds, counties_filt, counties_filt1, topo_base, roads_coarse, basemap, spp_cols,
   closest_sites, grps_most_dispersed, john_tigger, population_finder, reed_csv, bb1, rds_coarse, target_taxon_grp_fndr)


# raw data
out <- pts %>% 
  split(., 1:nrow(.))%>%
           purrr::map(pts_cell) %>% 
  bind_rows() %>% 
  st_as_sf() %>% 
  mutate(rownum = 1:nrow(.), .before = x) %>% 
  st_intersects(., pts)


AB <- window_search(out)  # ident_grp = 64, groups = 66
k <- gsub('row', '',names(AB))
keepers <- pts[k,]

# first iteration

polys1 <- keepers %>% 
  split(., 1:nrow(.))%>%
           purrr::map(pts_cell) %>% 
  bind_rows() %>% 
  st_as_sf() %>% 
  mutate(POLY_ID = 1:nrow(.))

pts <- pts %>% mutate(PL_ID = 1:nrow(.))
out <- st_intersection(pts, polys1)

tp <- out %>% 
  ungroup() %>% 
  group_by(PL_ID) %>% 
  tally() %>% 
  filter(n >1)


  # 1 - Intersect all points to the remaining cells. 
  # 2 - determine which points are present in multiple windows
  # 3 - if a cell does NOT contain any novel points - drop it

new_polys <-st_join(polys1, tp, left = F) %>% 
  distinct(POLY_ID, .keep_all = T) %>% 
  st_union() %>% 
  st_cast("POLYGON") %>% 
  st_as_sf() %>% 
  mutate(CAST_ID = 1:nrow(.))

pt_grps <- st_intersection(pts, new_polys) %>% 
  group_by(CAST_ID) 

babadook <- split(pt_grps, ~CAST_ID)


center_windows <- function(x){
  
  output <- x %>% 
    st_as_sf() %>% 
    st_union() %>% 
    st_cast('MULTIPOINT') %>% 
    st_centroid()
  
  return(output)
}

new_centers <- lapply(lapply(babadook, center_windows), pts_cell) %>% bind_rows()


# let us see about doing the following to these results:
  # 1 - Intersect all points to the remaining cells. 
  # 2 - determine which points are present in multiple windows
  # 3 - if a cell does NOT contain any novel points - drop it
  # 4 - union all points per cell
  # 5 - take the centroid of the unioned points
  # 6 - buffer from there

ggplot() +
  geom_sf(data = new_centers, alpha = 0.2, fill = 'red') +
  geom_sf(data = tp) +
  theme_bw()

```

```{r}

```

## create more basemaps

Now we will download a basemap for each population, we will start testing them out on at a time

```{r, warning = F}

bb2 <- townsendia %>% filter(rcrdNmb == 761) %>% 
  st_buffer(2000) %>% 
  st_transform(4326) %>% 
  st_bbox()

bb3 <- bb2
names(bb3) <- c('left', 'bottom', 'right', 'top')
basemap_t <- ggmap::get_stamenmap(bb3, zoom = 13, maptype = "terrain")


mapbb <- townsendia %>% filter(rcrdNmb == 761) %>% 
  st_buffer(10000) %>% 
  st_transform(4326) %>% 
  st_bbox() %>% 
  st_as_sfc() %>% 
  st_as_sf()


ggmap::ggmap(basemap) +
  geom_sf(data = counties_filt1, lty = 3, inherit.aes = FALSE) +
  geom_sf(data = rds_coarse, inherit.aes = F, colour = 'grey20') +
  geom_sf(data = pts, aes(color = scntfcN), inherit.aes = FALSE) +
  geom_sf(data = mapbb, fill = NA, color = "red", size = 1.0, inherit.aes = F) +
  scale_color_manual(values= spp_cols)+
  coord_sf(xlim = c(bb1[1], bb1[3]), ylim = c(bb1[2], bb1[4])) +  
  labs(title="Sampled Populations",  x ="", y = "", color = 'Species') +
  theme_bw() +
  theme(axis.text.x=element_blank(),
        axis.text.y = element_blank(),
        plot.title = element_text(hjust = 0.5),
        legend.position="bottom",
        legend.direction = "horizontal",
        panel.border = element_rect(colour = "black", fill=NA),
        legend.background = element_rect(linetype = 2, size = 0.5, colour = 1)) +
  annotation_scale(location = "bl", width_hint = 0.4) +
    annotation_north_arrow(location = "tl", which_north = "true", 
        height = unit(0.8, "cm"),  width = unit(0.6, "cm"),
        pad_x = unit(0.0, "in"), pad_y = unit(0.0, "in"),
        style = north_arrow_orienteering)





```


Create a couple types of base maps for recycling throughout the process.
```{r create some basemaps}
base <- ggplot() +
  geom_sf(data = montrose_buffer, fill = 'bisque2', alpha = 0.2)  +
  geom_sf(data = montrose) +
  theme_bw()
```


```{r}
# step 3 #######################################
# Identify identical groups with >2 members

ident_grps <- outer(groups, groups, Vectorize(setequal)) == T

shared_groups <- which(ident_grps, arr=T)
#alpha <- data.frame(shared_groups)
shared_groups <- data.frame(cbind(rownames(shared_groups), shared_groups))
rownames(shared_groups) <- NULL
colnames(shared_groups) <- c('target','row','col')
shared_groups <- shared_groups %>% 
  data.frame() %>% 
  mutate(target = str_remove(target, '[.].*')) %>% 
  arrange(
    str_remove(target, 'row') %>% as.numeric()
  )

shared_groups$match <-colnames(ident_grps)[as.numeric(shared_groups$col)]
unrepo <- shared_groups[shared_groups$target != shared_groups$match,c(1,4)]

igraph_ob <- igraph::graph.data.frame(unrepo, directed=FALSE)
ident_grps <- lapply(igraph::groups(igraph::components(igraph_ob)), FUN =  data.frame)
plot(igraph_ob)
names(ident_grps) <- c(1:length(ident_grps))
ident_grps <- Map(cbind, ident_grps, Group = names(ident_grps))
ident_grps <- bind_rows(ident_grps) 
names(ident_grps) <- c('Individual', 'Groups')

ident_grps %>% 
  add_count(Groups) %>% 
  filter(n > 2)

rm(ident, igraph_ob, ident_grps)
```

